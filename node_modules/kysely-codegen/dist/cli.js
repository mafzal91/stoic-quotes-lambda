"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Cli_instances, _Cli_generate, _Cli_getLogLevel, _Cli_parseOptions;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cli = void 0;
const minimist_1 = __importDefault(require("minimist"));
const connection_string_parser_1 = require("./connection-string-parser");
const dialect_manager_1 = require("./dialect-manager");
const log_level_1 = require("./enums/log-level");
const generator_1 = require("./generator");
const logger_1 = require("./logger");
const DEFAULT_OUT_FILE = './node_modules/kysely-codegen/dist/db.d.ts';
const VALID_DIALECTS = ['mysql', 'postgres', 'sqlite'];
const VALID_FLAGS = new Set([
    '_',
    'camel-case',
    'dialect',
    'exclude-pattern',
    'h',
    'help',
    'include-pattern',
    'log-level',
    'out-file',
    'print',
    'url',
]);
/**
 * Creates a kysely-codegen command-line interface.
 */
class Cli {
    constructor() {
        _Cli_instances.add(this);
    }
    async run(argv) {
        const options = __classPrivateFieldGet(this, _Cli_instances, "m", _Cli_parseOptions).call(this, argv);
        await __classPrivateFieldGet(this, _Cli_instances, "m", _Cli_generate).call(this, options);
    }
}
exports.Cli = Cli;
_Cli_instances = new WeakSet(), _Cli_generate = async function _Cli_generate(options) {
    const { camelCase } = options;
    const logger = new logger_1.Logger(options.logLevel);
    const connectionStringParser = new connection_string_parser_1.ConnectionStringParser();
    const { connectionString, inferredDialectName } = connectionStringParser.parse({
        connectionString: options.url,
        dialectName: options.dialectName,
        logger,
    });
    if (options.dialectName) {
        logger.info(`Using dialect '${options.dialectName}'.`);
    }
    else {
        logger.info(`No dialect specified. Assuming '${inferredDialectName}'.`);
    }
    const dialectManager = new dialect_manager_1.DialectManager();
    const dialect = dialectManager.getDialect(options.dialectName ?? inferredDialectName);
    const generator = new generator_1.Generator({
        camelCase,
        connectionString,
        dialect,
        logger,
    });
    await generator.generate(options);
}, _Cli_getLogLevel = function _Cli_getLogLevel(name) {
    switch (name) {
        case 'silent':
            return log_level_1.LogLevel.SILENT;
        case 'info':
            return log_level_1.LogLevel.INFO;
        case 'error':
            return log_level_1.LogLevel.ERROR;
        case 'debug':
            return log_level_1.LogLevel.DEBUG;
        default:
            return log_level_1.LogLevel.WARN;
    }
}, _Cli_parseOptions = function _Cli_parseOptions(args) {
    const argv = (0, minimist_1.default)(args);
    const _ = argv._;
    const camelCase = !!argv['camel-case'];
    const dialectName = argv.dialect;
    const help = !!argv.h || !!argv.help || _.includes('-h') || _.includes('--help');
    const excludePattern = argv['exclude-pattern'];
    const includePattern = argv['include-pattern'];
    const logLevel = __classPrivateFieldGet(this, _Cli_instances, "m", _Cli_getLogLevel).call(this, argv['log-level']);
    const outFile = argv['out-file'] ?? DEFAULT_OUT_FILE;
    const print = !!argv.print;
    const url = argv.url ?? 'env(DATABASE_URL)';
    const logger = new logger_1.Logger(logLevel);
    try {
        for (const key in argv) {
            if (!VALID_FLAGS.has(key)) {
                throw new RangeError(`Invalid flag: "${key}"`);
            }
        }
        const dialectValues = VALID_DIALECTS.join(', ');
        if (help) {
            logger.log('', 'kysely-codegen [options]', '', '  --all              Display all options.', '  --camel-case       Use the Kysely CamelCasePlugin.', `  --dialect          Set the SQL dialect. (values: [${dialectValues}])`, '  --help, -h         Print this message.', '  --exclude-pattern  Exclude tables matching the specified glob pattern. (examples: users, *.table, secrets.*, *._*)', '  --include-pattern  Only include tables matching the specified glob pattern. (examples: users, *.table, secrets.*, *._*)', '  --log-level        Set the terminal log level. (values: [debug, info, warn, error, silent], default: warn)', `  --out-file         Set the file build path. (default: ${DEFAULT_OUT_FILE})`, '  --print            Print the generated output to the terminal.', '  --url              Set the database connection string URL. This may point to an environment variable. (default: env(DATABASE_URL))', '');
            process.exit(0);
        }
        if (dialectName && !VALID_DIALECTS.includes(dialectName)) {
            throw new RangeError(`Parameter '--dialect' must have one of the following values: ${dialectValues}`);
        }
        if (!url) {
            throw new TypeError("Parameter '--url' must be a valid connection string. Examples:\n\n" +
                '  --url=postgres://username:password@mydomain.com/database\n' +
                '  --url=env(DATABASE_URL)');
        }
    }
    catch (error) {
        if (logLevel > log_level_1.LogLevel.SILENT) {
            if (error instanceof Error) {
                console.error(logger.serializeError(error.message));
                if (logLevel >= log_level_1.LogLevel.DEBUG) {
                    console.error();
                    throw error;
                }
                else {
                    process.exit(0);
                }
            }
            else {
                throw error;
            }
        }
    }
    return {
        camelCase,
        dialectName,
        excludePattern,
        includePattern,
        logLevel,
        outFile,
        print,
        url,
    };
};
//# sourceMappingURL=cli.js.map