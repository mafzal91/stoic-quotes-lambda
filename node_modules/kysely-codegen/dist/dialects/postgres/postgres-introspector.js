"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PostgresIntrospector_instances, _PostgresIntrospector_createDatabaseMetadata, _PostgresIntrospector_getEnums;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostgresIntrospector = void 0;
const enum_collection_1 = require("../../enum-collection");
const introspector_1 = require("../../introspector");
const metadata_1 = require("../../metadata");
class PostgresIntrospector extends introspector_1.Introspector {
    constructor() {
        super(...arguments);
        _PostgresIntrospector_instances.add(this);
    }
    async introspect(options) {
        const db = await this.connect(options);
        const tables = await db.introspection.getTables();
        const enums = await __classPrivateFieldGet(this, _PostgresIntrospector_instances, "m", _PostgresIntrospector_getEnums).call(this, db);
        await db.destroy();
        const metadata = __classPrivateFieldGet(this, _PostgresIntrospector_instances, "m", _PostgresIntrospector_createDatabaseMetadata).call(this, tables, enums);
        return metadata;
    }
}
exports.PostgresIntrospector = PostgresIntrospector;
_PostgresIntrospector_instances = new WeakSet(), _PostgresIntrospector_createDatabaseMetadata = function _PostgresIntrospector_createDatabaseMetadata(tables, enums) {
    const tablesMetadata = tables.map((table) => ({
        ...table,
        columns: table.columns.map((column) => ({
            ...column,
            enumValues: enums.get(column.dataType),
        })),
    }));
    return new metadata_1.DatabaseMetadata(tablesMetadata, enums);
}, _PostgresIntrospector_getEnums = async function _PostgresIntrospector_getEnums(db) {
    const enums = new enum_collection_1.EnumCollection();
    const rows = await db
        .selectFrom('pg_type')
        .innerJoin('pg_enum', 'pg_enum.enumtypid', 'pg_type.oid')
        .select(['pg_type.typname', 'pg_enum.enumlabel'])
        .execute();
    for (const row of rows) {
        enums.add(row.typname, row.enumlabel);
    }
    return enums;
};
//# sourceMappingURL=postgres-introspector.js.map