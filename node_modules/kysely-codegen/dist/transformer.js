"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Transformer_instances, _Transformer_camelCase, _Transformer_dialect, _Transformer_declarationNodes, _Transformer_defaultType, _Transformer_definitions, _Transformer_exportedProperties, _Transformer_imported, _Transformer_imports, _Transformer_symbols, _Transformer_types, _Transformer_createSymbolName, _Transformer_declareDefinition, _Transformer_declareSymbol, _Transformer_instantiateReferencedSymbol, _Transformer_instantiateReferencedSymbols, _Transformer_transformColumn, _Transformer_transformDatabaseExport, _Transformer_transformDeclarations, _Transformer_transformImports, _Transformer_transformTables;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transformer = void 0;
const case_converter_1 = require("./case-converter");
const definitions_1 = require("./constants/definitions");
const imports_1 = require("./constants/imports");
const node_type_1 = require("./enums/node-type");
const alias_declaration_node_1 = require("./nodes/alias-declaration-node");
const export_statement_node_1 = require("./nodes/export-statement-node");
const generic_expression_node_1 = require("./nodes/generic-expression-node");
const identifier_node_1 = require("./nodes/identifier-node");
const import_statement_node_1 = require("./nodes/import-statement-node");
const interface_declaration_node_1 = require("./nodes/interface-declaration-node");
const object_expression_node_1 = require("./nodes/object-expression-node");
const property_node_1 = require("./nodes/property-node");
const union_expression_node_1 = require("./nodes/union-expression-node");
const SYMBOLS = Object.fromEntries(Object.keys(definitions_1.GLOBAL_DEFINITIONS).map((key) => [key, false]));
const initialize = (dialect) => {
    return {
        declarationNodes: [],
        defaultType: dialect.adapter.defaultType ?? new identifier_node_1.IdentifierNode('unknown'),
        definitions: { ...definitions_1.GLOBAL_DEFINITIONS, ...dialect.adapter.definitions },
        exportedProperties: [],
        imported: {},
        imports: { ...imports_1.GLOBAL_IMPORTS, ...dialect.adapter.imports },
        symbols: { ...SYMBOLS },
        types: dialect.adapter.types ?? {},
    };
};
/**
 * Converts table metadata to a codegen AST.
 */
class Transformer {
    constructor(dialect, camelCase) {
        _Transformer_instances.add(this);
        _Transformer_camelCase.set(this, void 0);
        _Transformer_dialect.set(this, void 0);
        _Transformer_declarationNodes.set(this, void 0);
        _Transformer_defaultType.set(this, void 0);
        _Transformer_definitions.set(this, void 0);
        _Transformer_exportedProperties.set(this, void 0);
        _Transformer_imported.set(this, void 0);
        _Transformer_imports.set(this, void 0);
        _Transformer_symbols.set(this, void 0);
        _Transformer_types.set(this, void 0);
        __classPrivateFieldSet(this, _Transformer_camelCase, camelCase, "f");
        __classPrivateFieldSet(this, _Transformer_dialect, dialect, "f");
        const options = initialize(dialect);
        __classPrivateFieldSet(this, _Transformer_declarationNodes, options.declarationNodes, "f");
        __classPrivateFieldSet(this, _Transformer_defaultType, options.defaultType, "f");
        __classPrivateFieldSet(this, _Transformer_definitions, options.definitions, "f");
        __classPrivateFieldSet(this, _Transformer_exportedProperties, options.exportedProperties, "f");
        __classPrivateFieldSet(this, _Transformer_imported, options.imported, "f");
        __classPrivateFieldSet(this, _Transformer_imports, options.imports, "f");
        __classPrivateFieldSet(this, _Transformer_symbols, options.symbols, "f");
        __classPrivateFieldSet(this, _Transformer_types, options.types, "f");
    }
    transform(tables) {
        const options = initialize(__classPrivateFieldGet(this, _Transformer_dialect, "f"));
        __classPrivateFieldSet(this, _Transformer_declarationNodes, options.declarationNodes, "f");
        __classPrivateFieldSet(this, _Transformer_defaultType, options.defaultType, "f");
        __classPrivateFieldSet(this, _Transformer_definitions, options.definitions, "f");
        __classPrivateFieldSet(this, _Transformer_exportedProperties, options.exportedProperties, "f");
        __classPrivateFieldSet(this, _Transformer_imported, options.imported, "f");
        __classPrivateFieldSet(this, _Transformer_imports, options.imports, "f");
        __classPrivateFieldSet(this, _Transformer_symbols, options.symbols, "f");
        __classPrivateFieldSet(this, _Transformer_types, options.types, "f");
        const tableExportNodes = __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_transformTables).call(this, tables);
        const importNodes = __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_transformImports).call(this);
        const definitionExportNodes = __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_transformDeclarations).call(this);
        const databaseExportNode = __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_transformDatabaseExport).call(this);
        const exportNodes = [
            ...definitionExportNodes,
            ...tableExportNodes,
            databaseExportNode,
        ];
        return [...importNodes, ...exportNodes];
    }
}
exports.Transformer = Transformer;
_Transformer_camelCase = new WeakMap(), _Transformer_dialect = new WeakMap(), _Transformer_declarationNodes = new WeakMap(), _Transformer_defaultType = new WeakMap(), _Transformer_definitions = new WeakMap(), _Transformer_exportedProperties = new WeakMap(), _Transformer_imported = new WeakMap(), _Transformer_imports = new WeakMap(), _Transformer_symbols = new WeakMap(), _Transformer_types = new WeakMap(), _Transformer_instances = new WeakSet(), _Transformer_createSymbolName = function _Transformer_createSymbolName(table) {
    let symbolName = __classPrivateFieldGet(this, _Transformer_dialect, "f").getSymbolName(table);
    if (__classPrivateFieldGet(this, _Transformer_symbols, "f")[symbolName] !== undefined) {
        let suffix = 2;
        while (__classPrivateFieldGet(this, _Transformer_symbols, "f")[`${symbolName}${suffix}`] !== undefined) {
            suffix++;
        }
        symbolName += suffix;
    }
    return symbolName;
}, _Transformer_declareDefinition = function _Transformer_declareDefinition(name, definition) {
    if (__classPrivateFieldGet(this, _Transformer_symbols, "f")[name]) {
        return;
    }
    const [generics, expression] = Array.isArray(definition)
        ? definition
        : [[], definition];
    __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_declareSymbol).call(this, name);
    if (expression.type === node_type_1.NodeType.OBJECT_EXPRESSION) {
        __classPrivateFieldGet(this, _Transformer_declarationNodes, "f").push(new interface_declaration_node_1.InterfaceDeclarationNode(name, expression));
    }
    else {
        __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_declareSymbol).call(this, name);
        __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_instantiateReferencedSymbols).call(this, expression);
        __classPrivateFieldGet(this, _Transformer_declarationNodes, "f").push(new alias_declaration_node_1.AliasDeclarationNode(name, generics, expression));
    }
}, _Transformer_declareSymbol = function _Transformer_declareSymbol(name) {
    __classPrivateFieldGet(this, _Transformer_symbols, "f")[name] = true;
}, _Transformer_instantiateReferencedSymbol = function _Transformer_instantiateReferencedSymbol(name) {
    var _a;
    const definition = __classPrivateFieldGet(this, _Transformer_definitions, "f")[name];
    if (definition && !__classPrivateFieldGet(this, _Transformer_symbols, "f")[name]) {
        __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_declareDefinition).call(this, name, definition);
        return;
    }
    const importModuleName = __classPrivateFieldGet(this, _Transformer_imports, "f")[name];
    if (importModuleName) {
        __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_declareSymbol).call(this, name);
        (_a = __classPrivateFieldGet(this, _Transformer_imported, "f"))[importModuleName] ?? (_a[importModuleName] = new Set());
        __classPrivateFieldGet(this, _Transformer_imported, "f")[importModuleName].add(name);
    }
}, _Transformer_instantiateReferencedSymbols = function _Transformer_instantiateReferencedSymbols(node) {
    switch (node.type) {
        case node_type_1.NodeType.ARRAY_EXPRESSION:
            __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_instantiateReferencedSymbols).call(this, node.values);
            break;
        case node_type_1.NodeType.EXTENDS_CLAUSE:
            __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_instantiateReferencedSymbols).call(this, node.test);
            __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_instantiateReferencedSymbols).call(this, node.consequent);
            __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_instantiateReferencedSymbols).call(this, node.alternate);
            break;
        case node_type_1.NodeType.GENERIC_EXPRESSION: {
            __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_instantiateReferencedSymbol).call(this, node.name);
            for (const arg of node.args) {
                __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_instantiateReferencedSymbols).call(this, arg);
            }
            break;
        }
        case node_type_1.NodeType.IDENTIFIER:
            __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_instantiateReferencedSymbol).call(this, node.name);
            break;
        case node_type_1.NodeType.INFER_CLAUSE:
            break;
        case node_type_1.NodeType.MAPPED_TYPE:
            __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_instantiateReferencedSymbols).call(this, node.value);
            break;
        case node_type_1.NodeType.OBJECT_EXPRESSION:
            for (const property of node.properties) {
                __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_instantiateReferencedSymbols).call(this, property.value);
            }
            break;
        case node_type_1.NodeType.UNION_EXPRESSION:
            for (const arg of node.args) {
                __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_instantiateReferencedSymbols).call(this, arg);
            }
            break;
    }
}, _Transformer_transformColumn = function _Transformer_transformColumn(column) {
    const node = __classPrivateFieldGet(this, _Transformer_types, "f")[column.dataType] ?? __classPrivateFieldGet(this, _Transformer_defaultType, "f");
    const args = [node];
    if (column.isNullable) {
        args.push(new identifier_node_1.IdentifierNode('null'));
    }
    const key = __classPrivateFieldGet(this, _Transformer_camelCase, "f") ? (0, case_converter_1.toCamelCase)(column.name) : column.name;
    let value = args.length === 1 ? args[0] : new union_expression_node_1.UnionExpressionNode(args);
    if (column.hasDefaultValue || column.isAutoIncrementing) {
        value = new generic_expression_node_1.GenericExpressionNode('Generated', [value]);
    }
    __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_instantiateReferencedSymbols).call(this, value);
    return new property_node_1.PropertyNode(key, value);
}, _Transformer_transformDatabaseExport = function _Transformer_transformDatabaseExport() {
    return new export_statement_node_1.ExportStatementNode(new interface_declaration_node_1.InterfaceDeclarationNode('DB', new object_expression_node_1.ObjectExpressionNode(__classPrivateFieldGet(this, _Transformer_exportedProperties, "f"))));
}, _Transformer_transformDeclarations = function _Transformer_transformDeclarations() {
    return __classPrivateFieldGet(this, _Transformer_declarationNodes, "f")
        .sort((a, b) => {
        return a.type === b.type
            ? a.name.localeCompare(b.name)
            : a.type.localeCompare(b.type);
    })
        .map((node) => new export_statement_node_1.ExportStatementNode(node));
}, _Transformer_transformImports = function _Transformer_transformImports() {
    return Object.entries(__classPrivateFieldGet(this, _Transformer_imported, "f")).map(([moduleName, importNames]) => {
        return new import_statement_node_1.ImportStatementNode(moduleName, [...importNames]);
    });
}, _Transformer_transformTables = function _Transformer_transformTables(tables) {
    const nodes = [];
    for (const table of tables) {
        const tableSymbolName = __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_createSymbolName).call(this, table);
        const propertyNodes = [];
        __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_declareSymbol).call(this, tableSymbolName);
        const valueNode = new identifier_node_1.IdentifierNode(tableSymbolName);
        const key = __classPrivateFieldGet(this, _Transformer_dialect, "f").getExportedTableName(table, __classPrivateFieldGet(this, _Transformer_camelCase, "f"));
        const exportedPropertyNode = new property_node_1.PropertyNode(key, valueNode);
        __classPrivateFieldGet(this, _Transformer_exportedProperties, "f").push(exportedPropertyNode);
        for (const column of table.columns) {
            const propertyNode = __classPrivateFieldGet(this, _Transformer_instances, "m", _Transformer_transformColumn).call(this, column);
            propertyNodes.push(propertyNode);
        }
        const objectNode = new object_expression_node_1.ObjectExpressionNode(propertyNodes);
        const interfaceNode = new interface_declaration_node_1.InterfaceDeclarationNode(tableSymbolName, objectNode);
        const exportStatementNode = new export_statement_node_1.ExportStatementNode(interfaceNode);
        nodes.push(exportStatementNode);
    }
    return nodes;
};
//# sourceMappingURL=transformer.js.map